# SkillsSeal: Verifiable Agent Platform — Build Plan

## What We're Building

A web platform where users deploy their own general-purpose verifiable AI agent into an EigenCompute TEE. Each agent has a sovereign wallet, encrypted API credentials, and access to a curated skill registry. The agent uses EigenAI to route user tasks to the right skill and executes them with a full signed audit trail.

Three components:

1. **Skill Registry** — a curated GitHub repo of agent skills (folders with SKILL.md + scripts), indexed by a GitHub Action into registry.json.
2. **Agent Container** — a Docker image deployed per-user into EigenCompute TEE, with sovereign wallet, EigenAI routing, sandboxed skill execution, and signed logging.
3. **Platform (Frontend + Backend)** — a web app where users connect their wallet, configure env vars, deploy their agent, submit tasks, and monitor execution.

---

## Architecture

```
┌──────────────────────────────────────────────────────────────┐
│                     USER (Browser)                            │
│   Connects wallet → Configures env vars → Deploys agent       │
└───────────────────────────┬──────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                 EIGENSKILLS PLATFORM                          │
│                                                              │
│  ┌──────────────┐  ┌──────────────────┐  ┌───────────────┐  │
│  │   Frontend    │  │  Backend (API)   │  │  Database      │  │
│  │   (Next.js)   │  │  (Express/SIWE)  │  │  (Supabase)   │  │
│  └──────────────┘  └──────────────────┘  └───────────────┘  │
└───────────────────────────┬──────────────────────────────────┘
                            │
              POST /app/deploy (image_ref + user .env)
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                   EIGENCOMPUTE                                │
│                                                              │
│  Provisions TEE (Intel TDX)                                  │
│  Encrypts env vars with KMS                                  │
│  Injects sovereign wallet (MNEMONIC)                         │
│  Returns: app_id, wallet addresses, instance IP               │
└───────────────────────────┬──────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│              USER'S AGENT (Docker in TEE)                     │
│                                                              │
│  ┌─────────────┐  ┌──────────┐  ┌────────────────────────┐  │
│  │ TEE Wallet   │  │ EigenAI  │  │ Skill Runner           │  │
│  │ (viem)       │  │ (router) │  │ (sandboxed env vars)   │  │
│  └─────────────┘  └──────────┘  └────────────────────────┘  │
│                                                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ Encrypted env vars (API keys, decrypted only in TEE)    │ │
│  └─────────────────────────────────────────────────────────┘ │
└───────────────────────────┬──────────────────────────────────┘
                            │
              ┌─────────────┼─────────────┐
              ▼             ▼             ▼
       ┌────────────┐ ┌─────────┐ ┌──────────────┐
       │ Skill      │ │ EigenAI │ │ External     │
       │ Registry   │ │ API     │ │ APIs (called │
       │ (GitHub)   │ │         │ │ by skills)   │
       └────────────┘ └─────────┘ └──────────────┘
```

---

## Component 1: Skill Registry (GitHub)

**Live Registry:** https://github.com/38d3b7/eigenskills/tree/main/registry/skills

### Repo Structure

```
skillsseal-registry/
├── README.md
├── registry.json              ← auto-generated index of all skills
├── skills/
│   ├── humanize-ai-text/
│   │   ├── SKILL.md           ← frontmatter + instructions
│   │   ├── scripts/
│   │   │   ├── detect.py
│   │   │   ├── transform.py
│   │   │   └── compare.py
│   │   └── patterns.json
│   ├── translate-text/
│   │   ├── SKILL.md
│   │   └── scripts/
│   │       └── translate.py
│   └── twitter-thread/
│       ├── SKILL.md
│       └── scripts/
│           └── split.py
```

### SKILL.md Format

Frontmatter schema is team-designed. Minimum fields the agent needs for routing:

```yaml
---
name: humanize-ai-text
description: >
  Short description of what this skill does.
  This is what EigenAI reads to route tasks.
version: 1.0.0
author: publisher-github-username
content-hash: sha256:abc123...    # auto-generated by GitHub Action
requires_env:                     # sandboxed: agent only passes these to the skill
  - OPENAI_API_KEY
execution:
  - run: python scripts/detect.py {{input}}
  - run: python scripts/transform.py {{input}} -o {{output}}
dependencies:
  - python3
  - pip:unidecode
---
```

Key fields:
- `description` — EigenAI reads this to match against user tasks
- `requires_env` — agent only passes these env vars to the skill subprocess (sandboxed execution)
- `execution` — optional structured steps. If present, agent runs directly. If absent, agent asks EigenAI to plan the steps.
- `content-hash` — SHA-256 of the skill folder, auto-generated by GitHub Action

### registry.json

Auto-generated by GitHub Action on every merge to main:

```json
{
  "skills": [
    {
      "id": "humanize-ai-text",
      "description": "Humanize AI-generated text...",
      "version": "1.0.0",
      "author": "publisher-github-username",
      "contentHash": "sha256:abc123...",
      "requiresEnv": ["OPENAI_API_KEY"],
      "hasExecutionManifest": true
    }
  ]
}
```

### GitHub Action

On PR merge to main:
1. Validates SKILL.md frontmatter (name, description, version, author, requires_env)
2. Computes content hash of the skill folder
3. Regenerates `registry.json`

### Curation Model

Skills are admitted via PR with maintainer review. This is the quality and safety gate. No auto-merge. The GitHub Action only indexes skills that have been merged by a maintainer.

---

## Component 2: Agent Container

### Structure

```
agent/
├── Dockerfile
├── .env.example
├── package.json
├── tsconfig.json
├── src/
│   ├── index.ts              ← entry point, Express HTTP server
│   ├── wallet.ts             ← TEE wallet derivation (viem)
│   ├── router.ts             ← EigenAI skill routing (tool calling)
│   ├── registry.ts           ← fetches and caches skill registry from GitHub
│   ├── executor.ts           ← runs skills with sandboxed env vars
│   └── logger.ts             ← signed execution log
```

### Dockerfile

See [docs/eigencompute-reference.md](eigencompute-reference.md) for full requirements.

```dockerfile
FROM --platform=linux/amd64 node:18
USER root
WORKDIR /app

RUN apt-get update && apt-get install -y python3 python3-pip git && \
    pip3 install --break-system-packages requests unidecode

COPY package.json tsconfig.json ./
RUN npm install
COPY src/ ./src/

EXPOSE 3000
CMD ["npx", "tsx", "src/index.ts"]
```

### Core Modules

#### `wallet.ts` — TEE Wallet (viem)

```typescript
import { mnemonicToAccount } from "viem/accounts";

const mnemonic = process.env.MNEMONIC;
if (!mnemonic) throw new Error("MNEMONIC not set");

export const wallet = mnemonicToAccount(mnemonic);
```

#### `registry.ts` — Skill Registry Client

- On startup: fetch registry.json from GitHub (raw URL)
- Parse into memory, expose: `listSkills()`, `getSkill(id)`, `fetchSkillFolder(id)`
- `fetchSkillFolder`: git sparse-checkout the specific skill into `/tmp/skills/{id}/`
- Verify content hash matches registry.json
- Refresh on a timer (e.g., every 10 minutes)
- Filter skills by user's available env vars (only route to skills whose `requires_env` the user has configured)

#### `router.ts` — EigenAI Skill Router (Tool Calling + Grant Auth)

- Takes: user task (string) + available skill list (filtered by user's env vars)
- Authenticates via grant-based wallet signature (no API key needed)
- Calls EigenAI with `tools` parameter for structured skill selection
- Uses `gpt-oss-120b-f16` model, `seed=42` for determinism
- Parses `tool_calls` response for skill IDs
- Caches grant credentials (message + signature) for reuse
- Stores the EigenAI `signature` for the routing decision
- See [docs/eigenai-reference.md](eigenai-reference.md) for API details

#### `executor.ts` — Sandboxed Skill Runner

- Takes: skill folder path + user input + skill's `requires_env` list
- Reads SKILL.md from the folder
- **Sandboxed execution**: constructs a minimal environment containing ONLY the vars listed in `requires_env`, sourced from `process.env`
- If SKILL.md has `execution` block: run commands directly via `child_process.execSync`
- If no `execution` block: send SKILL.md + task to EigenAI to plan commands
- Captures stdout/stderr for each step
- Returns: output text + execution log

#### `logger.ts` — Signed Execution Log

Every action is logged and signed with the TEE wallet:
- Task received (timestamp, task text)
- Routing decision (skill IDs, EigenAI signature)
- Skill fetched (skill ID, content hash verified)
- Commands executed (command, stdout, stderr, exit code)
- Result returned (output, agent signature)

#### `index.ts` — HTTP Server (Express)

```
POST /task
  Body: { task: string }
  - Router picks skill(s) via EigenAI (filtered to user's available skills)
  - Executor runs with sandboxed env vars
  - Sign result with TEE wallet
  - Return: { result, skillsUsed, routingSignature, agentSignature, agentAddress }

GET /skills
  - Returns available skills (filtered by user's env vars)

GET /history
  - Returns the signed execution log

GET /whoami
  - Returns: agent wallet address, TEE attestation info, skill registry URL

GET /health
  - Liveness check
```

### Required Env Vars

```bash
MNEMONIC              # auto-injected by KMS, never set manually
EIGENAI_GRANT_API     # defaults to https://determinal-api.eigenarcade.com
SKILL_REGISTRY_URL    # set by platform (GitHub raw URL)
NETWORK_PUBLIC        # "sepolia" or "mainnet" (visible on dashboard)
```

> **Note:** No `EIGENAI_KEY` is required. The agent authenticates to EigenAI using grant-based wallet signature with its TEE-derived wallet. See [docs/eigenai-reference.md](eigenai-reference.md) for details.

---

## Component 3: Platform (Frontend + Backend)

### Backend: Orchestration Layer

Express server with SIWE auth that mediates between the frontend and EigenCompute.

#### API Routes

```
POST /api/agents/deploy
  Body: { envVars: [{key, value, isPublic}], name: string }
  Auth: SIWE (wallet signature)
  Action: constructs .env, calls EigenCompute POST /app/deploy with image_ref
  Returns: { appId, walletAddress, instanceIp }

POST /api/agents/upgrade
  Body: { envVars: [{key, value, isPublic}] }
  Auth: SIWE
  Action: constructs .env, calls POST /apps/{app-id}/upgrade
  Returns: { success }

POST /api/agents/stop
POST /api/agents/start
POST /api/agents/terminate
  Auth: SIWE
  Action: proxies to EigenCompute

GET /api/agents/info
  Auth: SIWE
  Returns: { status, walletAddress, instanceIp, dockerDigest, createdAt }

GET /api/agents/logs
  Auth: SIWE
  Returns: agent stdout/stderr from EigenCompute
```

#### Deploy Flow

1. Frontend collects env vars as key-value pairs with public/private toggle
2. Backend constructs `.env` file (appending `_PUBLIC` suffix where toggled)
3. Backend calls EigenCompute deploy API with pre-built `image_ref` + user `.env`
4. EigenCompute encrypts env vars with KMS, provisions TEE, injects wallet
5. Backend stores `app_id`, wallet addresses, instance IP in database
6. Backend returns agent details to frontend

#### Auth: Sign In With Ethereum (SIWE)

User connects wallet, signs a message, backend verifies. No passwords, no email. User's ETH address = account.

### Frontend: Web App

#### Page 1: Home / Landing
- "Deploy your verifiable AI agent"
- Connect wallet (MetaMask / WalletConnect)
- Returning users → dashboard. New users → setup.

#### Page 2: Agent Setup
- **Step 1:** Name your agent
- **Step 2:** Configure env vars (key-value form, public/private toggle per var)
- **Step 3:** Review and deploy

#### Page 3: Dashboard
- Agent status card (running/stopped/deploying)
- Wallet address (ETH + Solana) with copy button
- Instance IP, Docker digest, uptime
- Verifiability Dashboard link
- Quick actions: Stop / Start / Update Env Vars / Terminate
- Task interface: submit tasks, see signed results
- Available skills from registry
- Execution history from agent

#### Page 4: Update Env Vars
- Key-value form pre-populated with current var names
- Add/remove/update vars
- Save triggers `POST /apps/{app-id}/upgrade`

---

## Skill Trust Model

### Curated Registry
Skills are admitted via PR with maintainer review. No auto-merge. This is the quality gate.

### Sandboxed Env Vars
Skills declare `requires_env` in SKILL.md. The agent executor only passes those vars to the subprocess. `MNEMONIC` and other agent-internal secrets are never exposed to skills.

### Implicit Filtering
If a skill requires an env var the user hasn't configured, the agent won't route to it. All users see the same curated registry.

---

## Build Sequence

### Phase 1: Foundation (Week 1-2)

1. **Skill registry** — repo structure, SKILL.md spec, 2-3 example skills, GitHub Action for registry.json
2. **Agent container** — wallet.ts, registry.ts, router.ts, executor.ts, logger.ts, index.ts, Dockerfile

### Phase 2: Platform (Week 3-4)

3. **Backend** — Express server, SIWE auth, EigenCompute API integration, user-agent DB
4. **Frontend** — Next.js, wallet connect, agent setup wizard, env var UI, dashboard, task submission

### Phase 3: Integration + Deploy (Week 5)

5. **Publish agent image** to Docker registry
6. **Deploy backend**
7. **Test full flow on Sepolia:** connect wallet → configure env vars → deploy agent → submit task → see signed result
8. **Verify TEE attestation** on EigenCompute Verifiability Dashboard

---

## Reference Docs

- [docs/eigenai-reference.md](eigenai-reference.md) — EigenAI API, models, endpoints, tool calling, signature verification
- [docs/eigencompute-reference.md](eigencompute-reference.md) — Dockerfile requirements, ecloud CLI, env vars, deploy flow, app lifecycle

## Context7 Library IDs

| Library | Context7 ID | Use |
|---------|-------------|-----|
| EigenCloud docs | `/layr-labs/eigencloud-docs` | EigenCompute, EigenAI, TEE, wallet |
| ethers v6 | `/websites/ethers_v6` | SIWE verification, signature verification |
| Express | `/expressjs/express` | Backend + agent HTTP servers |
| Commander.js | `/tj/commander.js` | CLI (if needed alongside frontend) |
| viem | (use npm docs) | Agent wallet derivation |

---

## Key Design Decisions

1. **One agent image, many deployments.** Same Docker image, different env vars per user. Each user gets their own TEE + wallet.
2. **Platform deploys on behalf of users.** Backend calls EigenCompute API. Users never touch the CLI.
3. **Env vars are the personalization layer.** The only difference between agents is their encrypted env vars and auto-generated wallet.
4. **`_PUBLIC` convention in UI.** Users toggle vars between encrypted (default) and public.
5. **Wallet connect is identity.** SIWE auth, no passwords.
6. **Agent is sovereign.** Users talk directly to their agent for tasks. Platform is only for deployment management.
7. **Curated registry replaces staking.** Maintainer review is the trust layer.
8. **Sandboxed env vars replace slashing.** Skills only get what they declare.
9. **Billing model deferred.** All deployments under platform account for now.

---

## Deployment Troubleshooting

### Common Issues and Solutions

| Error | Cause | Solution |
|-------|-------|----------|
| `ExitPromptError: User force closed the prompt` | CLI expects interactive input | Pipe `echo N \|` before the command |
| `command compute:app:deploy:myimage:latest not found` | Colon in positional argument parsed as subcommand | Use `--image-ref` flag instead |
| `spawnSync /bin/sh ENOBUFS` | `yes N \|` produces infinite output | Use `echo N \|` instead |
| `Failed to pull image ... 404` | Image not on Docker Hub | Build and push: `docker build --platform linux/amd64 && docker push` |
| `Docker is not running` | Docker daemon not started | Start Docker Desktop |
| Private key in error logs | `execSync` includes full command in errors | Wrap in try/catch, sanitize with regex |

### Backend Environment Variables

```bash
# backend/.env
EIGENCOMPUTE_PRIVATE_KEY=...   # Your ecloud wallet private key
AGENT_IMAGE_REF=username/skillsseal-agent:latest  # Docker Hub image
EIGENCOMPUTE_ENVIRONMENT=sepolia
FRONTEND_URL=http://localhost:3000
PORT=3002
```

### Pre-Deployment Checklist

1. **Docker image built for `linux/amd64`**
   ```bash
   docker build --platform linux/amd64 -t username/skillsseal-agent:latest ./agent
   ```

2. **Docker image pushed to Docker Hub**
   ```bash
   docker push username/skillsseal-agent:latest
   ```

3. **Backend `.env` configured** with `EIGENCOMPUTE_PRIVATE_KEY` and `AGENT_IMAGE_REF`

4. **Sepolia ETH funded** to your ecloud wallet (`ecloud auth whoami`)

5. **Billing subscribed** via `ecloud billing subscribe`

---

## What This Does NOT Include (V2+)

- EigenLayer AVS integration
- Agent-to-agent communication
- Skill marketplace with payments
- Multi-agent orchestration
- Skill dependency chains
- Per-user skill preferences
- Usage-based reputation scoring
- Network sandboxing for skills
