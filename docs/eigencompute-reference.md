# EigenCompute Reference

> Source: Context7 `/layr-labs/eigencloud-docs`

## Overview

EigenCompute deploys containerized applications into Trusted Execution Environments (TEEs) using Intel TDX. Each deployment gets:

- A unique wallet identity (MNEMONIC env var generated by deployer, encrypted via KMS)
- Encrypted environment variables (stored on-chain, decrypted only inside the TEE)
- A unique instance IP and app ID
- Cryptographic attestation of the Docker image running

## Chains and Environments

EigenCompute has exactly **two environments**:

| Environment | Chain | Chain ID | RPC |
|-------------|-------|----------|-----|
| `sepolia` | Ethereum Sepolia (testnet) | `11155111` | `https://ethereum-sepolia-rpc.publicnode.com` |
| `mainnet-alpha` | Ethereum Mainnet | `1` | `https://ethereum-rpc.publicnode.com` |

**Not Base Sepolia.** EigenCompute registers deployments, encrypted env vars, and Docker digests on Ethereum L1. The `ecloud` CLI `--environment` flag only accepts `sepolia` or `mainnet-alpha`.

Set the environment via CLI flag or env var:

```bash
# CLI flag
ecloud compute app deploy --environment sepolia

# Or environment variable
export ECLOUD_ENV=sepolia
```

### Verifiability Dashboards

| Environment | Dashboard URL |
|-------------|---------------|
| Sepolia | `https://verify-sepolia.eigencloud.xyz` |
| Mainnet | `https://verify.eigencloud.xyz` |

## Billing and Credits

EigenCompute uses a **USD credit/billing system**, not an on-chain token.

### Setup

```bash
# Subscribe to billing (required before first deploy)
ecloud billing subscribe
# Opens payment portal — new customers get $100 credit
```

### Funding Your Wallet

The wallet used for `ecloud` commands needs ETH on the appropriate chain for gas:

```bash
# Get your ecloud wallet address
ecloud auth whoami

# Fund with Sepolia ETH for testnet (use a Sepolia faucet)
# Fund with Mainnet ETH for production
```

### Cost Management

- **Stop apps when not testing** — `ecloud compute app stop` preserves wallet and IP but stops billing
- **Never terminate unless necessary** — `terminate` destroys the wallet permanently
- **Use `--log-visibility public`** during development for easier debugging

## Dockerfile Requirements

**All three are mandatory. Missing any causes deployment failure or unreachable containers.**

```dockerfile
# REQUIRED: Must target linux/amd64
FROM --platform=linux/amd64 node:18

# REQUIRED: Must run as root (TEE requirement)
USER root

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

## Network Binding (Critical)

**The application MUST bind to `0.0.0.0`, not `localhost` / `127.0.0.1`.**

Inside the TEE container, binding to `localhost` makes the server only accept connections from within the container itself. External traffic (including health checks and API calls from the backend) will get `ECONNREFUSED` even though the container is running and the port is exposed.

```typescript
// WRONG — unreachable from outside the TEE
app.listen(3000, () => { ... });

// CORRECT — accepts external connections
app.listen(3000, "0.0.0.0", () => { ... });
```

This applies to Express, Fastify, or any HTTP server running inside EigenCompute. The symptom of getting this wrong is a deployed container that shows `Status: running` but returns `ECONNREFUSED` or connection timeouts on the instance IP.

## Environment Variables

### Security Model

- Standard `.env` variables are **encrypted** with a KMS key unique to your TEE
- Encrypted env vars are stored **on-chain**
- Decryption happens **only inside your specific TEE at runtime**
- Variables are accessible via standard `process.env` in your application

### `_PUBLIC` Suffix Convention

Variables ending in `_PUBLIC` are **visible on-chain and to users** (on the Verifiability Dashboard). All other variables are encrypted.

```bash
# Encrypted (private to TEE)
EIGENAI_KEY=your_key
DATABASE_URL=postgres://...

# Visible on-chain (transparency)
NETWORK_PUBLIC=sepolia
REGISTRY_URL_PUBLIC=https://github.com/org/repo
```

**Never put API keys or secrets in `_PUBLIC` variables.**

### MNEMONIC

- **Generated by the backend** at deploy time using BIP39 (`@scure/bip39`)
- Passed as a private env var (encrypted by KMS, decrypted inside TEE)
- Persists across `stop`/`start` and `upgrade` operations (preserved from stored env vars)
- **Destroyed permanently** on `terminate`

**Important:** The KMS does NOT generate the mnemonic. KMS only encrypts env vars during deploy and decrypts them at container startup. The mnemonic must be explicitly generated and injected by the deployment orchestrator (backend).

## Storage and Persistence

EigenCompute provides **no persistent storage**. There are no volumes, no disk mounts, and no way to persist data to the container filesystem.

### What Gets Wiped

| Event | Filesystem | In-Memory State | Wallet | IP |
|-------|------------|-----------------|--------|-----|
| `stop` then `start` | Wiped | Lost | Preserved | Usually preserved |
| `upgrade` | Wiped | Lost | Preserved | Usually preserved |
| `terminate` | Destroyed | Lost | **Destroyed** | Lost |

### Persistence Strategy

Since the container filesystem is ephemeral, all persistent data must go through **external storage**:

- **Supabase / PostgreSQL** — Structured data, user records, task history
- **IPFS / Arweave** — Immutable content, skill artifacts
- **Backend API** — Platform-managed state, agent metadata

### Signed State Pattern

When storing state externally, the agent should sign its state before saving and verify signatures when loading. This ensures:

1. **Integrity** — State hasn't been tampered with in external storage
2. **Authenticity** — State was created by this agent's wallet
3. **Freshness** — Include timestamps or nonces to prevent replay

```typescript
// Save state: sign before storing
const state = { config: {...}, lastUpdated: Date.now() };
const signature = await wallet.signMessage(JSON.stringify(state));
await externalStorage.save({ state, signature, address: wallet.address });

// Load state: verify before using
const { state, signature, address } = await externalStorage.load();
const recovered = verifyMessage(JSON.stringify(state), signature);
if (recovered !== wallet.address) throw new Error("State verification failed");
```

This pattern maintains verifiability even though the storage layer is untrusted.

## TEE Wallet

Each deployed app receives a persistent, private wallet that serves as its cryptographic identity.

### Deriving the Wallet (TypeScript — viem)

```typescript
import { mnemonicToAccount } from "viem/accounts";

const account = mnemonicToAccount(process.env.MNEMONIC);
console.log("Address:", account.address);

// Sign messages
const signature = await account.signMessage({
  message: "Attestation from verified agent"
});

// Send transactions
const tx = await walletClient.sendTransaction({
  account,
  to: recipientAddress,
  value: amount
});
```

### Deriving the Wallet (TypeScript — ethers v6)

```typescript
import { ethers } from "ethers";

const wallet = ethers.Wallet.fromPhrase(process.env.MNEMONIC);
console.log("Address:", wallet.address);
```

### Deriving the Wallet (Python)

```python
import os
from eth_account import Account

Account.enable_unaudited_hdwallet_features()
account = Account.from_mnemonic(os.environ['MNEMONIC'])
```

## Attestation and Verifiability

EigenCompute provides cryptographic attestation that proves which Docker image is running inside the TEE. Understanding this model is critical for maintaining verifiability.

### How Attestation Works

1. When you deploy, the **Docker image digest** (sha256 hash) is recorded on-chain
2. The TEE generates a cryptographic proof that this exact image has access to the wallet
3. Anyone can verify on the [Verifiability Dashboard](https://verify-sepolia.eigencloud.xyz) that the running code matches the attested image

### The Trust Anchors

| Anchor | What It Proves | Persistence |
|--------|----------------|-------------|
| **Wallet address** | Identity — "this is agent X" | Survives upgrades |
| **Docker digest** | Code — "agent X runs image Y" | Changes on upgrade |
| **TEE attestation** | Binding — "only image Y can access wallet X" | Regenerated on upgrade |

### Self-Modification Breaks Verifiability

The agent runs as `root` inside the container, so it *can* modify its own files at runtime. However:

- The on-chain attestation still refers to the **original image digest**
- Modified code runs **unattested** — there's no proof of what's actually executing
- This is a **verifiability violation** that undermines the trust model

**Never modify source files at runtime.** If code needs to change, use `upgrade` to deploy a new attested image.

### Evolution Strategies

Two patterns for agents that need to change behavior over time:

**Config-Driven Evolution (Recommended)**
- Same Docker image, behavior changes through external config/data
- Attestation remains valid — code is unchanged
- Load configuration from external storage using signed-state pattern
- Example: skill weights, prompt templates, routing rules

**Upgrade-Mediated Evolution**
- New Docker image deployed via `ecloud compute app upgrade`
- New attestation generated for new image
- Wallet and grants preserved — identity continuity
- Example: bug fixes, new features, dependency updates

Config-driven evolution is preferred because it requires no image rebuilds and maintains a single attested codebase.

## CLI Commands

### First-Time Setup

```bash
# Auth
ecloud auth login

# Subscribe to billing (required before first deploy, $100 credit for new users)
ecloud billing subscribe
```

### Deploy

```bash
# From Dockerfile in current directory
ecloud compute app deploy

# From pre-built image
ecloud compute app deploy myregistry/myapp:v1.0
```

#### Deploy API (Programmatic)

```
POST /app/deploy

Parameters:
  --private-key     Private key for signing (env: $EIGENX_PRIVATE_KEY)
  --environment     "sepolia" or "mainnet-alpha"
  --env-file        Path to .env file (default: .env)
  --image_ref       Pre-built Docker image reference
  --log-visibility  "public", "private", or "off"
  --instance-type   "g1-standard-4t" or "g1-standard-8t"
  --name            Display name for the application
  --resource-usage-monitoring  "enable" or "disable"

Response:
  { "message": "Application deployed successfully.", "app_id": "app_12345abcde" }
```

#### Deploy Process

1. Builds Docker image for `linux/amd64` (or uses `image_ref`)
2. Pushes image to Docker registry
3. Encrypts `.env` with KMS public key (RSA-OAEP + AES-256-GCM)
4. Submits transaction to blockchain (image digest + encrypted secrets + public vars)
5. Provisions TEE instance with Intel TDX
6. Injects KMS-generated wallet mnemonic
7. Returns app details + wallet addresses (ETH + Solana)

### App Management

```bash
# List all deployed apps
ecloud compute app list

# Get detailed info (status, IP, wallet, env, digest)
ecloud compute app info <name>

# View logs (stdout/stderr)
ecloud compute app logs <name>

# Stop (preserves wallet + IP, reduces cost)
ecloud compute app stop <name>

# Restart stopped app (same wallet + IP restored)
ecloud compute app start <name>

# Update env vars or image (wallet persists)
ecloud compute app upgrade <name>

# IRREVERSIBLE: wallet access lost forever
ecloud compute app terminate <name>
```

### Upgrade (Update Env Vars)

```
POST /apps/{app-id}/upgrade

Parameters:
  --env-file        New .env file
  --image_ref       New Docker image (optional)
  --instance-type   New instance type (optional)
  --log-visibility  New visibility setting (optional)

The wallet persists across upgrades. Only env vars and/or image change.
```

### Safe Termination Workflow

```bash
# 1. Stop app
ecloud compute app stop my-app

# 2. Get wallet address
ecloud compute app info my-app

# 3. Check for funds on blockchain explorer
# 4. Withdraw funds using app code or manual transaction

# 5. Backup logs
ecloud compute app logs my-app > backup.log

# 6. Terminate permanently (IRREVERSIBLE)
ecloud compute app terminate my-app
```

## App Info Output

```
App ID: 42
Status: running
Docker Digest: sha256:4f6c2b3a...
Instance IP: 203.0.113.45
TEE Wallet (Ethereum): 0x1234567890abcdef1234567890abcdef12345678
TEE Wallet (Solana): ExampleSo1anaWa11etAddressXXXXXXXXXXXXXXXXXXX
Environment Variables:
  NETWORK_PUBLIC: sepolia
Created: 2025-01-07
```

## App Profile (Verifiability Dashboard)

```bash
ecloud compute app profile set <name> \
  --name "My Agent" \
  --website "https://example.com" \
  --description "Verifiable AI agent" \
  --x-url "https://twitter.com/user" \
  --image ./icon.png
```

Profile fields appear on the Verifiability Dashboard:
- Mainnet: `https://verify.eigencloud.xyz`
- Sepolia: `https://verify-sepolia.eigencloud.xyz`

## Instance Types

| Type | Description |
|------|-------------|
| `g1-standard-4t` | Standard 4-thread instance |
| `g1-standard-8t` | Standard 8-thread instance |

## Programmatic Usage (Node.js)

### Recommended: `@layr-labs/ecloud-sdk` (No Docker Required)

The official TypeScript SDK (`@layr-labs/ecloud-sdk`) provides a programmatic API for all EigenCompute operations. It handles KMS encryption, on-chain transactions, and UserAPI calls internally — **no Docker daemon or CLI binary needed**.

This is the default deploy strategy in `backend/src/eigencompute-sdk.ts`.

```typescript
import { createECloudClient } from "@layr-labs/ecloud-sdk";

const client = createECloudClient({
  verbose: false,
  privateKey: "0x...",        // EIGENCOMPUTE_PRIVATE_KEY
  environment: "sepolia",     // or "mainnet-alpha"
  // rpcUrl: "..."            // optional custom RPC
});

// Deploy using pre-built image (no Docker needed)
const { prepared, gasEstimate } = await client.compute.app.prepareDeployFromVerifiableBuild({
  name: "my-agent",
  imageRef: "username/myimage:latest",
  imageDigest: "sha256:abc123...",   // from Docker Hub API
  envFile: "/path/to/.env",
  instanceType: "g1-standard-4t",
  logVisibility: "public",
  resourceUsageMonitoring: "enable",
});

const result = await client.compute.app.executeDeploy(prepared, gasEstimate);
const ip = await client.compute.app.watchDeployment(result.appId);

// Lifecycle
await client.compute.app.stop(result.appId);
await client.compute.app.start(result.appId);
await client.compute.app.terminate(result.appId);

// Upgrade (also Docker-free)
const upgrade = await client.compute.app.prepareUpgradeFromVerifiableBuild(appId, {
  imageRef: "username/myimage:v2",
  imageDigest: "sha256:def456...",
  envFile: "/path/to/.env",
  instanceType: "g1-standard-4t",
  logVisibility: "public",
});
await client.compute.app.executeUpgrade(upgrade.prepared, upgrade.gasEstimate);
await client.compute.app.watchUpgrade(appId);
```

#### Getting the Image Digest (No Docker)

The image digest can be fetched from Docker Hub's API without needing Docker installed:

```typescript
async function getImageDigest(imageRef: string): Promise<string> {
  const [repo, tag = "latest"] = imageRef.split(":");
  const res = await fetch(`https://hub.docker.com/v2/repositories/${repo}/tags/${tag}`);
  const data = await res.json();
  const amd64 = data.images?.find((i: any) => i.architecture === "amd64");
  return amd64?.digest ?? data.digest;
}
```

#### Deploy Strategies

The backend uses CLI as primary with SDK fallback:

| Strategy | When Used | Docker? | Description |
|----------|-----------|---------|-------------|
| **CLI** (primary) | Always tried first | No | `ecloud` CLI with tested flags, auto-layers TEE tools |
| SDK (fallback) | When CLI fails + non-verifiable | No | `@layr-labs/ecloud-sdk` — only for non-verifiable builds |
| GitHub Actions | When `USE_GITHUB_ACTIONS=true` | No (on host) | Triggers workflow, async webhook callback |

**Note:** The `DEPLOY_STRATEGY` env var is still read but CLI is always tried first regardless of its value (unless GitHub Actions is explicitly enabled).

### Legacy: `ecloud` CLI Usage

When using the CLI directly from Node.js (strategy `cli`), several issues arise:

#### Non-Interactive Prompts

The `ecloud` CLI uses Inquirer.js for interactive prompts. When run non-interactively, it throws:

```
ExitPromptError: User force closed the prompt with 13 null
```

**Solution:** Pipe `echo N |` to auto-answer prompts. Do NOT use `yes N |` — it causes `ENOBUFS` buffer overflow.

#### Image Reference as Flag

The oclif-based CLI misinterprets colons in positional arguments. Always use `--image-ref`:

```bash
# WRONG
ecloud compute app deploy myregistry/myimage:latest

# CORRECT
ecloud compute app deploy --image-ref myregistry/myimage:latest
```

#### Private Key Handling

Pass the private key explicitly via `--private-key` flag. Always sanitize error messages to prevent private key exposure in logs.

### Docker Image Requirements

The agent image must be:
1. **Built for `linux/amd64`** — EigenCompute TEEs run on x86_64
2. **Pushed to a public registry** — EigenCompute pulls from Docker Hub

```bash
docker build --platform linux/amd64 -t username/skillsseal-agent:latest ./agent
docker push username/skillsseal-agent:latest
```

### Environment Variables

| Variable | Description |
|----------|-------------|
| `EIGENCOMPUTE_PRIVATE_KEY` | Private key for signing deploy transactions |
| `AGENT_IMAGE_REF` | Docker image reference (e.g., `username/myagent:latest`) |
| `EIGENCOMPUTE_ENVIRONMENT` | `sepolia` or `mainnet-alpha` |
| `DEPLOY_STRATEGY` | `sdk` (default), `github-actions`, or `cli` |
| `EIGENCOMPUTE_RPC_URL` | Optional custom RPC endpoint |

## Key Constraints

### Build Requirements
- Docker image **must** target `linux/amd64`
- Application **must** run as `root` (TEE requirement)

### Wallet Lifecycle
- `MNEMONIC` is auto-injected — do not set manually
- `terminate` is irreversible — wallet is destroyed forever
- `upgrade` preserves wallet — use for code/config updates
- `stop`/`start` preserves wallet and usually IP

### Storage and State
- **No persistent storage** — filesystem wiped on stop/start/upgrade
- In-memory state is lost on any restart — use external storage
- Encrypted env vars are only accessible inside the TEE — do not exfiltrate

### Verifiability
- Attestation is **Docker-digest-specific** — proves exact image
- Runtime file modifications run **unattested** — avoid self-editing code
- Config-driven evolution preserves attestation; upgrade-mediated generates new attestation

## Deploy Architecture (SkillsSeal-Specific)

### Three-Hop Task Execution

```
┌──────────────┐     ┌──────────────┐     ┌──────────────────────┐
│   Frontend   │────▶│   Backend    │────▶│   TEE Agent          │
│   (Vercel)   │     │   (Fly.io)   │     │   (EigenCompute)     │
└──────────────┘     └──────────────┘     └──────────────────────┘
       │                    │                       │
       │  SIWE auth +       │  HTTP proxy to        │  EigenAI routing,
       │  task submit       │  agent instance IP    │  skill execution,
       │                    │                       │  wallet signatures
```

**Why the backend proxy?**
- The agent runs inside a TEE with a raw IP — no HTTPS, no CORS headers
- The backend handles SIWE auth, rate limiting, and health checks
- Frontend-to-backend is HTTPS; backend-to-agent is HTTP (within GCP network)

### Environment Variable Encryption Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  DEPLOY TIME                                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. Backend generates MNEMONIC (BIP39)                                      │
│  2. Backend injects system vars (BACKEND_URL, SKILL_REGISTRY_URL, etc.)     │
│  3. SDK encrypts private vars with KMS public key (RSA-OAEP + AES-256-GCM)  │
│  4. Public vars (ending in _PUBLIC) stored in plaintext on-chain            │
│  5. Encrypted blob stored on-chain alongside Docker digest                  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  TEE BOOT TIME                                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. Confidential Space VM boots with attested Docker image                  │
│  2. ENTRYPOINT runs compute-source-env.sh                                   │
│  3. kms-client contacts KMS server (internal GCP IP)                        │
│  4. KMS decrypts env vars using attestation (proves this image, this TEE)   │
│  5. Decrypted vars exported to environment                                  │
│  6. exec hands off to application CMD                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  APPLICATION RUNTIME                                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  - MNEMONIC available in process.env → wallet.ts derives viem account       │
│  - BACKEND_URL available → sessions, heartbeats work                        │
│  - Grant credentials available → EigenAI routing works                      │
│  - All vars only exist in memory inside the TEE                             │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### CLI Auto-Layering (Recommended)

The `ecloud` CLI's `deploy` command automatically "layers" your Docker image with TEE tooling:
- Adds `compute-source-env.sh` as ENTRYPOINT
- Adds `kms-client` binary
- Adds `kms-signing-public-key.pem`
- Adds required TEE labels

**This means your Dockerfile can be simple** — no manual TEE setup required:

```dockerfile
FROM --platform=linux/amd64 node:18
USER root
WORKDIR /app

COPY package*.json ./
RUN npm install
COPY . .

EXPOSE 3000
CMD ["npm", "start"]
```

The CLI handles all TEE tooling automatically at deploy time.

### SDK Path (Fallback Only)

The SDK's `prepareDeployFromVerifiableBuild()` **skips auto-layering** — it deploys your image as-is. This was previously the default but required manual TEE toolchain setup in the Dockerfile.

**The CLI path is now preferred** because:
1. Simpler Dockerfiles (no TEE tools to maintain)
2. CLI auto-layers the latest TEE toolchain
3. Supports verifiable build prompt (user choice for on-chain attestation)

The SDK is only used as a fallback when CLI fails and the build is non-verifiable.

### Verifiable Build Option

When deploying via CLI, there's one interactive prompt: "Build from verifiable source?" (y/N)

- **Yes (verifiable):** Creates on-chain attestation proving the source code matches the deployed image
- **No (standard):** Faster deployment without source verification

The frontend exposes this as a toggle in the agent setup wizard (default: verifiable).

### Debugging Checklist

When env vars aren't reaching the container:

1. **Check /whoami endpoint** — if `agentAddress` is zero address, MNEMONIC didn't arrive
2. **Check TEE logs** — look for "compute-source-env.sh" or "kms-client" output
3. **Verify CLI was used** — CLI auto-layers TEE tooling; SDK path requires manual setup
4. **Check backend injection** — system vars (MNEMONIC, BACKEND_URL) must be in the envVars array passed to `deployAgent()`
