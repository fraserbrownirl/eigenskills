# EigenCompute Reference

> Source: Context7 `/layr-labs/eigencloud-docs`

## Overview

EigenCompute deploys containerized applications into Trusted Execution Environments (TEEs) using Intel TDX. Each deployment gets:

- A unique KMS-generated wallet (MNEMONIC env var, ETH + Solana addresses)
- Encrypted environment variables (stored on-chain, decrypted only inside the TEE)
- A unique instance IP and app ID
- Cryptographic attestation of the Docker image running

## Chains and Environments

EigenCompute has exactly **two environments**:

| Environment | Chain | Chain ID | RPC |
|-------------|-------|----------|-----|
| `sepolia` | Ethereum Sepolia (testnet) | `11155111` | `https://ethereum-sepolia-rpc.publicnode.com` |
| `mainnet-alpha` | Ethereum Mainnet | `1` | `https://ethereum-rpc.publicnode.com` |

**Not Base Sepolia.** EigenCompute registers deployments, encrypted env vars, and Docker digests on Ethereum L1. The `ecloud` CLI `--environment` flag only accepts `sepolia` or `mainnet-alpha`.

Set the environment via CLI flag or env var:

```bash
# CLI flag
ecloud compute app deploy --environment sepolia

# Or environment variable
export ECLOUD_ENV=sepolia
```

### Verifiability Dashboards

| Environment | Dashboard URL |
|-------------|---------------|
| Sepolia | `https://verify-sepolia.eigencloud.xyz` |
| Mainnet | `https://verify.eigencloud.xyz` |

## Billing and Credits

EigenCompute uses a **USD credit/billing system**, not an on-chain token.

### Setup

```bash
# Subscribe to billing (required before first deploy)
ecloud billing subscribe
# Opens payment portal — new customers get $100 credit
```

### Funding Your Wallet

The wallet used for `ecloud` commands needs ETH on the appropriate chain for gas:

```bash
# Get your ecloud wallet address
ecloud auth whoami

# Fund with Sepolia ETH for testnet (use a Sepolia faucet)
# Fund with Mainnet ETH for production
```

### Cost Management

- **Stop apps when not testing** — `ecloud compute app stop` preserves wallet and IP but stops billing
- **Never terminate unless necessary** — `terminate` destroys the wallet permanently
- **Use `--log-visibility public`** during development for easier debugging

## Dockerfile Requirements

**Both are mandatory. Missing either causes deployment failure.**

```dockerfile
# REQUIRED: Must target linux/amd64
FROM --platform=linux/amd64 node:18

# REQUIRED: Must run as root (TEE requirement)
USER root

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

## Environment Variables

### Security Model

- Standard `.env` variables are **encrypted** with a KMS key unique to your TEE
- Encrypted env vars are stored **on-chain**
- Decryption happens **only inside your specific TEE at runtime**
- Variables are accessible via standard `process.env` in your application

### `_PUBLIC` Suffix Convention

Variables ending in `_PUBLIC` are **visible on-chain and to users** (on the Verifiability Dashboard). All other variables are encrypted.

```bash
# Encrypted (private to TEE)
EIGENAI_KEY=your_key
DATABASE_URL=postgres://...

# Visible on-chain (transparency)
NETWORK_PUBLIC=sepolia
REGISTRY_URL_PUBLIC=https://github.com/org/repo
```

**Never put API keys or secrets in `_PUBLIC` variables.**

### MNEMONIC

- Auto-generated by KMS at deployment time
- **Never set manually**
- Persists across `stop`/`start` and `upgrade` operations
- **Destroyed permanently** on `terminate`

## Storage and Persistence

EigenCompute provides **no persistent storage**. There are no volumes, no disk mounts, and no way to persist data to the container filesystem.

### What Gets Wiped

| Event | Filesystem | In-Memory State | Wallet | IP |
|-------|------------|-----------------|--------|-----|
| `stop` then `start` | Wiped | Lost | Preserved | Usually preserved |
| `upgrade` | Wiped | Lost | Preserved | Usually preserved |
| `terminate` | Destroyed | Lost | **Destroyed** | Lost |

### Persistence Strategy

Since the container filesystem is ephemeral, all persistent data must go through **external storage**:

- **Supabase / PostgreSQL** — Structured data, user records, task history
- **IPFS / Arweave** — Immutable content, skill artifacts
- **Backend API** — Platform-managed state, agent metadata

### Signed State Pattern

When storing state externally, the agent should sign its state before saving and verify signatures when loading. This ensures:

1. **Integrity** — State hasn't been tampered with in external storage
2. **Authenticity** — State was created by this agent's wallet
3. **Freshness** — Include timestamps or nonces to prevent replay

```typescript
// Save state: sign before storing
const state = { config: {...}, lastUpdated: Date.now() };
const signature = await wallet.signMessage(JSON.stringify(state));
await externalStorage.save({ state, signature, address: wallet.address });

// Load state: verify before using
const { state, signature, address } = await externalStorage.load();
const recovered = verifyMessage(JSON.stringify(state), signature);
if (recovered !== wallet.address) throw new Error("State verification failed");
```

This pattern maintains verifiability even though the storage layer is untrusted.

## TEE Wallet

Each deployed app receives a persistent, private wallet that serves as its cryptographic identity.

### Deriving the Wallet (TypeScript — viem)

```typescript
import { mnemonicToAccount } from "viem/accounts";

const account = mnemonicToAccount(process.env.MNEMONIC);
console.log("Address:", account.address);

// Sign messages
const signature = await account.signMessage({
  message: "Attestation from verified agent"
});

// Send transactions
const tx = await walletClient.sendTransaction({
  account,
  to: recipientAddress,
  value: amount
});
```

### Deriving the Wallet (TypeScript — ethers v6)

```typescript
import { ethers } from "ethers";

const wallet = ethers.Wallet.fromPhrase(process.env.MNEMONIC);
console.log("Address:", wallet.address);
```

### Deriving the Wallet (Python)

```python
import os
from eth_account import Account

Account.enable_unaudited_hdwallet_features()
account = Account.from_mnemonic(os.environ['MNEMONIC'])
```

## Attestation and Verifiability

EigenCompute provides cryptographic attestation that proves which Docker image is running inside the TEE. Understanding this model is critical for maintaining verifiability.

### How Attestation Works

1. When you deploy, the **Docker image digest** (sha256 hash) is recorded on-chain
2. The TEE generates a cryptographic proof that this exact image has access to the wallet
3. Anyone can verify on the [Verifiability Dashboard](https://verify-sepolia.eigencloud.xyz) that the running code matches the attested image

### The Trust Anchors

| Anchor | What It Proves | Persistence |
|--------|----------------|-------------|
| **Wallet address** | Identity — "this is agent X" | Survives upgrades |
| **Docker digest** | Code — "agent X runs image Y" | Changes on upgrade |
| **TEE attestation** | Binding — "only image Y can access wallet X" | Regenerated on upgrade |

### Self-Modification Breaks Verifiability

The agent runs as `root` inside the container, so it *can* modify its own files at runtime. However:

- The on-chain attestation still refers to the **original image digest**
- Modified code runs **unattested** — there's no proof of what's actually executing
- This is a **verifiability violation** that undermines the trust model

**Never modify source files at runtime.** If code needs to change, use `upgrade` to deploy a new attested image.

### Evolution Strategies

Two patterns for agents that need to change behavior over time:

**Config-Driven Evolution (Recommended)**
- Same Docker image, behavior changes through external config/data
- Attestation remains valid — code is unchanged
- Load configuration from external storage using signed-state pattern
- Example: skill weights, prompt templates, routing rules

**Upgrade-Mediated Evolution**
- New Docker image deployed via `ecloud compute app upgrade`
- New attestation generated for new image
- Wallet and grants preserved — identity continuity
- Example: bug fixes, new features, dependency updates

Config-driven evolution is preferred because it requires no image rebuilds and maintains a single attested codebase.

## CLI Commands

### First-Time Setup

```bash
# Auth
ecloud auth login

# Subscribe to billing (required before first deploy, $100 credit for new users)
ecloud billing subscribe
```

### Deploy

```bash
# From Dockerfile in current directory
ecloud compute app deploy

# From pre-built image
ecloud compute app deploy myregistry/myapp:v1.0
```

#### Deploy API (Programmatic)

```
POST /app/deploy

Parameters:
  --private-key     Private key for signing (env: $EIGENX_PRIVATE_KEY)
  --environment     "sepolia" or "mainnet-alpha"
  --env-file        Path to .env file (default: .env)
  --image_ref       Pre-built Docker image reference
  --log-visibility  "public", "private", or "off"
  --instance-type   "g1-standard-4t" or "g1-standard-8t"
  --name            Display name for the application
  --resource-usage-monitoring  "enable" or "disable"

Response:
  { "message": "Application deployed successfully.", "app_id": "app_12345abcde" }
```

#### Deploy Process

1. Builds Docker image for `linux/amd64` (or uses `image_ref`)
2. Pushes image to Docker registry
3. Encrypts `.env` with KMS public key (RSA-OAEP + AES-256-GCM)
4. Submits transaction to blockchain (image digest + encrypted secrets + public vars)
5. Provisions TEE instance with Intel TDX
6. Injects KMS-generated wallet mnemonic
7. Returns app details + wallet addresses (ETH + Solana)

### App Management

```bash
# List all deployed apps
ecloud compute app list

# Get detailed info (status, IP, wallet, env, digest)
ecloud compute app info <name>

# View logs (stdout/stderr)
ecloud compute app logs <name>

# Stop (preserves wallet + IP, reduces cost)
ecloud compute app stop <name>

# Restart stopped app (same wallet + IP restored)
ecloud compute app start <name>

# Update env vars or image (wallet persists)
ecloud compute app upgrade <name>

# IRREVERSIBLE: wallet access lost forever
ecloud compute app terminate <name>
```

### Upgrade (Update Env Vars)

```
POST /apps/{app-id}/upgrade

Parameters:
  --env-file        New .env file
  --image_ref       New Docker image (optional)
  --instance-type   New instance type (optional)
  --log-visibility  New visibility setting (optional)

The wallet persists across upgrades. Only env vars and/or image change.
```

### Safe Termination Workflow

```bash
# 1. Stop app
ecloud compute app stop my-app

# 2. Get wallet address
ecloud compute app info my-app

# 3. Check for funds on blockchain explorer
# 4. Withdraw funds using app code or manual transaction

# 5. Backup logs
ecloud compute app logs my-app > backup.log

# 6. Terminate permanently (IRREVERSIBLE)
ecloud compute app terminate my-app
```

## App Info Output

```
App ID: 42
Status: running
Docker Digest: sha256:4f6c2b3a...
Instance IP: 203.0.113.45
TEE Wallet (Ethereum): 0x1234567890abcdef1234567890abcdef12345678
TEE Wallet (Solana): ExampleSo1anaWa11etAddressXXXXXXXXXXXXXXXXXXX
Environment Variables:
  NETWORK_PUBLIC: sepolia
Created: 2025-01-07
```

## App Profile (Verifiability Dashboard)

```bash
ecloud compute app profile set <name> \
  --name "My Agent" \
  --website "https://example.com" \
  --description "Verifiable AI agent" \
  --x-url "https://twitter.com/user" \
  --image ./icon.png
```

Profile fields appear on the Verifiability Dashboard:
- Mainnet: `https://verify.eigencloud.xyz`
- Sepolia: `https://verify-sepolia.eigencloud.xyz`

## Instance Types

| Type | Description |
|------|-------------|
| `g1-standard-4t` | Standard 4-thread instance |
| `g1-standard-8t` | Standard 8-thread instance |

## Programmatic Usage (Node.js)

When invoking `ecloud` CLI commands from Node.js (e.g., via `execSync`), several issues arise due to the CLI's interactive nature.

### Non-Interactive Prompts

The `ecloud` CLI uses Inquirer.js for interactive prompts. When run non-interactively, it throws:

```
ExitPromptError: User force closed the prompt with 13 null
```

**Solution:** Pipe `echo N |` to auto-answer prompts (e.g., "Build from verifiable source?"):

```typescript
import { execSync } from "child_process";

// Auto-answer the "Build from verifiable source?" prompt with "N"
const output = execSync(`echo N | ecloud compute app deploy --image-ref myimage:latest ...`);
```

**Important:** Do NOT use `yes N |` — it produces infinite output and causes `ENOBUFS` buffer overflow errors.

### Image Reference as Flag

The oclif-based CLI misinterprets colons in positional arguments (e.g., `myimage:latest` is parsed as a subcommand). Always use the `--image-ref` flag:

```bash
# WRONG — CLI interprets colon as command separator
ecloud compute app deploy myregistry/myimage:latest

# CORRECT — use flag
ecloud compute app deploy --image-ref myregistry/myimage:latest
```

### Private Key Handling

Pass the private key explicitly via `--private-key` flag. The environment variable `ECLOUD_PRIVATE_KEY` may not be picked up in all contexts.

**Critical:** Sanitize error messages to prevent private key exposure in logs:

```typescript
function execWithSanitizedErrors(command: string, options: ExecSyncOptions): Buffer {
  try {
    return execSync(command, options);
  } catch (err: any) {
    // Redact private key from error messages
    const sanitized = (err.message || "")
      .replace(/--private-key\s+\S+/g, "--private-key [REDACTED]");
    throw new Error(sanitized);
  }
}
```

### Complete Example

```typescript
import { execSync, ExecSyncOptions } from "child_process";
import { writeFileSync, unlinkSync } from "fs";
import { randomBytes } from "crypto";

const EIGENCOMPUTE_PRIVATE_KEY = process.env.EIGENCOMPUTE_PRIVATE_KEY;
const AGENT_IMAGE_REF = process.env.AGENT_IMAGE_REF; // e.g., "username/eigenskills-agent:latest"

function deployAgent(name: string, envVars: Record<string, string>) {
  if (!EIGENCOMPUTE_PRIVATE_KEY) {
    throw new Error("EIGENCOMPUTE_PRIVATE_KEY not set");
  }

  // Write env vars to temp file
  const envFile = `/tmp/env-${randomBytes(8).toString("hex")}`;
  const envContent = Object.entries(envVars)
    .map(([k, v]) => `${k}=${v}`)
    .join("\n");
  writeFileSync(envFile, envContent);

  const command = `echo N | ecloud compute app deploy \
    --image-ref ${AGENT_IMAGE_REF} \
    --env-file ${envFile} \
    --environment sepolia \
    --private-key ${EIGENCOMPUTE_PRIVATE_KEY} \
    --log-visibility public \
    --name ${name}`;

  try {
    const output = execSync(command, { encoding: "utf8" });
    return parseDeployOutput(output);
  } catch (err: any) {
    const sanitized = (err.message || "")
      .replace(/--private-key\s+\S+/g, "--private-key [REDACTED]");
    throw new Error(`Deploy failed: ${sanitized}`);
  } finally {
    unlinkSync(envFile);
  }
}
```

### Docker Image Requirements

The agent image must be:
1. **Built for `linux/amd64`** — EigenCompute TEEs run on x86_64
2. **Pushed to a public registry** — EigenCompute pulls from Docker Hub

```bash
# Build for correct platform
docker build --platform linux/amd64 -t username/eigenskills-agent:latest ./agent

# Push to Docker Hub
docker push username/eigenskills-agent:latest
```

### Environment Variables

| Variable | Description |
|----------|-------------|
| `EIGENCOMPUTE_PRIVATE_KEY` | Private key for signing deploy transactions |
| `AGENT_IMAGE_REF` | Docker image reference (e.g., `username/myagent:latest`) |
| `EIGENCOMPUTE_ENVIRONMENT` | `sepolia` or `mainnet-alpha` |

## Key Constraints

### Build Requirements
- Docker image **must** target `linux/amd64`
- Application **must** run as `root` (TEE requirement)

### Wallet Lifecycle
- `MNEMONIC` is auto-injected — do not set manually
- `terminate` is irreversible — wallet is destroyed forever
- `upgrade` preserves wallet — use for code/config updates
- `stop`/`start` preserves wallet and usually IP

### Storage and State
- **No persistent storage** — filesystem wiped on stop/start/upgrade
- In-memory state is lost on any restart — use external storage
- Encrypted env vars are only accessible inside the TEE — do not exfiltrate

### Verifiability
- Attestation is **Docker-digest-specific** — proves exact image
- Runtime file modifications run **unattested** — avoid self-editing code
- Config-driven evolution preserves attestation; upgrade-mediated generates new attestation
